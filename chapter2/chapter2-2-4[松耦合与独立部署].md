#松耦合，独立部署
    
在传统的单块架构应用里，由于所有的功能都存在同一个代码库里。因此，当修改了代码库的某个功能，在后续的测试过程中
都需要做回归测试，才能保证当前功能的修改不会影响其他正常的功能。换句话说，功能和功能之间存在着强耦合关系。

当测试完成后，通过持续集成或者其他机制，会构建新版本的部署包。这个部署包里，包括了系统的所有功能。当将该部署包部署到生产环境或者类生产环境时，由于所有功能都运行在同一个进程中。因此，必须要首先停掉当前正在运行的进程，部署完成后，再重新启动进程，相信这个过程大家都不会陌生。

<img src="/images/loose-decouple-tradition-800-600.png" />

但是，如果当前应用程序里包含类似定时任务的功能，则要考虑什么时间窗口适合部署，是否需要先停掉原有的数据源或者消息队列，以防止数据被读入应用程序内存，但未处理完应用就被停止而导致的数据不一致性。

多年前，我曾经接触过一个JAVA项目，应用程序本身是个含有定时任务的系统，每隔5秒都会从数据库读入数据，然后将其转换成JMS的消息传给不同的内部组件。每次部署时候，我们都需要先关掉后台的消息队列，以防止数据被读入到应用，还未被处理完，部署停掉进程而导致的数据不一致性。

微服务架构中，每个服务都是一个独立的业务单元，服务和服务之间是松耦合的。当对某个服务进行改变时，对其他的服务并不
会产生影响。

对于每个服务，最好能使用独立的代码库。这样的话，当我们对当前服务的代码进行修改后，并不会影响其他服务。也就是说，从代码库的层面，服务与服务是松耦合、高度解耦的。

类似的，对于每个服务，都应该有独立的测试机制，对其所做的代码修改，并不必担心破坏其他功能而导致的大范围的回归测试，也就是说，从测试的角度而言，服务和服务之间也是松耦合、高度解耦的。

另外，由于构建包是独立的，部署流程也是独立的，服务的运行也是在不同的进程中。因此，从部署和运行的角度考虑，服务和服务之间同样是松耦合、高度解耦的。

<img src="/images/loose-decouple-microservice-800-600.png" />

所以说，对于微服务架构中的每个服务而言，与其他服务高度解耦。只改变当前服务本身，就可以完成独立的测试、构建以及部署等。