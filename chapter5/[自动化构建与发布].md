# 自动化构建与发布

上文中提到，每个服务都是一个可独立部署的业务单元，经过静态检查、代码度量、单元测试、接口测试等阶段后，构建符合需求的部署包，部署包存在的形式是多种多样的。

本例中，笔者选用了docker作为部署的工具，作为一种新兴的虚拟化方式，Docker跟传统的虚拟化方式相比具有众多的优势。首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 

其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。具体说来，Docker 在如下几个方面具有较大的优势。

 - 更快速的交付和部署

对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。
开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。

- 更高效的虚拟化

Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。

- 更轻松的迁移和扩展

Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。

- 更简单的管理

使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。

说了这么多好处，我们来看看使用docker怎么去构建并发布包含工程运行环境的镜像包。首先需要在项目的根目录创建一个Dockerfile:

```
FROM ruby:2.2.0
MAINTAINER YOUR NAME <YOUR EMAIL>

RUN mkdir /app

RUN apt-get update -y
RUN apt-get install -y libsqlite3-dev freetds-dev

WORKDIR /app

ADD Gemfile /app/Gemfile
ADD Gemfile.lock /app/Gemfile.lock
RUN bundle install

ADD . /app

EXPOSE 80
CMD bundle exec unicorn -c config/unicorn.rb -p 80
```

Docker能够自动读取Dockerfile中的指令来构建镜像包。 Dockerfile是一个文本文档，它实际上包含了你手动构建一个Docker镜像包的所有指令。通过在命令行执行docker build，Docker就会一步一步地执行Dockerfile中定义的指令。从上面的Dockerfile中可以看出，我们要构建的镜像包是基于一个基础的镜像包“ruby:2.2.0”，在它的基础上，首先清除/app文件夹，然后使用apt-get安装依赖的包，接着用bundler安装项目中用到的所有gem包，最后使用unicorn运行服务并开放80端口。整个过程一气呵成，Dockerfile帮我们省掉了许多手动操作的步骤。

既然有了Dockerfile，接下来要做的就是编写一个脚本将我们项目的构建以及发布自动化起来，因此就有了下面的build.sh：

```
#!/bin/bash

set -e 
set -x

DOCKER_REGISTRY_URL="YOUR REGISTRY URL"
DOCKER_REGISTRY_USER_NAME="USER NAME"
APP_NAME=${APP_NAME:-product-service}
BUILD_NUMBER=${BUILD_NUMBER:-dev}
VERSION=$(cat MAJOR_VERSION).$BUILD_NUMBER

FULL_TAG=${DOCKER_REGISTRY_URL:="localhost"}/$DOCKER_REGISTRY_USER_NAME/$APP_NAME:$VERSION

echo "Build and push Docker image to Registry"
echo "Building Docker image"
docker build -t $FULL_TAG .

if [ $DOCKER_REGISTRY_URL != "localhost" ]; then
  echo "Pushing Docker image to Registry"
  docker push $FULL_TAG
fi
```

build.sh实际上只做了两件事，首先通过执行docker build构建一个包含项目代码以及运行环境的镜像包，再使用docker push将其发布到某个docker registry中，这个docker registry可以是第三方的docker hub等，也可以自己搭建一个安全又私有的registry。
