# 持续集成

之前已经谈到对于服务本身，应该有独立的持续集成环境(CI)，以及在CI上配置好的相关运行的项目。从代码库而言，不同的服务，也需要有相应的脚本，来支持如何快速、有效安装并配置CI代理节点（Agent或者Slave）。所谓CI代理节点，通常是指能够从指定的版本库上下载最新源码，运行测试、构建包，执行部署的这样一类机器，可以是虚拟机，也可是物理机。

譬如，在笔者从事的项目中，每个服务的持续集成流水线通常会分成如下三个阶段：
- 构建
a) 静态检查          （代码规范检查)
b) 测试验证          （运行各种类型的测试）
c) 依赖包升级检测（检查当前Gem的待更新情况）
d) 构建RPM包      （生成应用的软件包）

- 发布
a) 创建AMI映像 （根据生成的RPM包，构建新的基于AWS的映像）
b) 打标签      （标签的目的是为了限制当前包，能够被部署在什么样的环境上。譬如对于类生产环境，应该期望仅当标记了staging后，才可以被部署到类生产环境）

- 部署
a) 部署到测试环境（通常情况下，测试环境主要是团队内部使用，因此每当有映像生成后，可以自动完成部署）
b) 部署到类生产环境 （通常其存在的目的是为业务团队做演示，一般是按需部署） 
c) 部署到生产环境       (产品环境一般为手动部署)

对于这些阶段，在实际的项目中，我们可以使用不同的rake任务来实现。例如： rake quality，rake spec等。

通过这些事先存在的rake任务，我们只需要定义一个通用的调用脚本，安装运行环境，就能帮助我们在持续集成节点（譬如Jenkins、Bamboo）中有效的执行任务。

ci.sh
```
#!/bin/bash
set -e

source ./ci-setup.sh

# Delegate to rake
bundle exec rake "$@"
```

ci-setup.sh
```
#!/bin/bash
set -e

# Check the directory
if [ -z "$PROJECT_ROOT_DIR" ]; then
  PROJECT_ROOT_DIR="."
fi

# Get Ruby version
RUBY_VERSION=$(cat ${PROJECT_ROOT_DIR}/.ruby-version | cut -d. -f1,2)
echo "Using ruby version ${RUBY_VERSION}"

# Install/Updgrade ruby
sudo yum install -y chruby-ruby-${RUBY_VERSION}

# Use ruby specified in .ruby-version file
source /usr/share/chruby/chruby.sh
chruby ruby-${RUBY_VERSION}
type ruby
ruby -v

# Bootstrap bundler
BUNDLER_VERSION=$(cat ${PROJECT_ROOT_DIR}/.bundler-version)
gem specification bundler -v "$BUNDLER_VERSION" >/dev/null 2>&1 || gem install --no-rdoc --no-ri bundler -v "$BUNDLER_VERSION"

bundle -v

bundle install --jobs 8 --retry 3
```
譬如，如果执行代码静态检查，则只需要在持续集成服务器上定义项目，设置运行命令为 ci.sh 'quality’即可。当然，我们也可以直接调用shell脚本，比如之前提到的用来构建docker镜像包的build.sh。
